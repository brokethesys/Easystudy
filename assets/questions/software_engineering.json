{
    "subject": "Программная инженерия",
    "tickets": [
        {
            "id": 1,
            "question": "Что такое Unified Modeling Language (UML) и зачем он нужен в разработке ПО?",
            "theory": "UML (Unified Modeling Language) — это стандартизированный графический язык моделирования для визуализации, специфицирования, конструирования и документирования артефактов программных систем. UML был создан для унификации различных нотаций объектно-ориентированного анализа и проектирования. Основные цели UML: 1) Предоставление средств для визуального моделирования, понятных как разработчикам, так и заказчикам. 2) Унификация подходов к описанию архитектуры и поведения системы. 3) Поддержка всего жизненного цикла разработки ПО (от анализа требований до реализации). UML используется для создания различных типов диаграмм, которые делятся на структурные (описывающие статическую структуру системы) и поведенческие (описывающие динамическое поведение). Язык помогает командам разработчиков лучше понимать систему, выявлять проблемы на ранних этапах, документировать решения и облегчает коммуникацию между стейкхолдерами.",
            "subquestions": [
                {
                    "subid": 1.1,
                    "question": "Какова основная цель создания UML?",
                    "type": "singleanswer",
                    "options": [
                        "Создание нового языка программирования",
                        "Унификация различных нотаций объектно-ориентированного моделирования",
                        "Автоматическая генерация кода без участия программиста",
                        "Замена естественного языка в технической документации"
                    ],
                    "correct_answer": 1,
                    "explanation": "UML был создан для объединения (унификации) множества существовавших в 1990-х годах методик и нотаций объектно-ориентированного анализа и проектирования (таких как Booch, OMT, OOSE)."
                },
                {
                    "subid": 1.2,
                    "question": "Какие из перечисленных утверждений о UML являются верными?",
                    "type": "multiplyanswer",
                    "options": [
                        "UML — это язык программирования",
                        "UML используется для визуализации архитектуры системы",
                        "Диаграммы UML могут документировать только статическую структуру",
                        "UML облегчает коммуникацию между разработчиками и заказчиками"
                    ],
                    "correct_answer": [
                        1,
                        3
                    ],
                    "explanation": "UML — это язык моделирования, а не программирования. Он используется и для визуализации структуры, и для описания поведения системы. Одно из ключевых преимуществ — улучшение коммуникации между всеми участниками проекта."
                },
                {
                    "subid": 1.3,
                    "question": "На каком этапе жизненного цикла ПО НЕ применяется UML?",
                    "type": "singleanswer",
                    "options": [
                        "Анализ требований",
                        "Проектирование архитектуры",
                        "Непосредственное выполнение (интерпретация) программы",
                        "Тестирование и документирование"
                    ],
                    "correct_answer": 2,
                    "explanation": "UML — это язык моделирования. Его диаграммы используются для анализа, проектирования, документации, но сами по себе они не выполняются как код. Для выполнения нужен код, написанный на языке программирования."
                },
                {
                    "subid": 1.4,
                    "question": "Кто является основной аудиторией UML-диаграмм?",
                    "type": "singleanswer",
                    "options": [
                        "Только программисты",
                        "Только системные архитекторы",
                        "Только бизнес-аналитики",
                        "Все стейкхолдеры проекта (заказчики, аналитики, архитекторы, разработчики, тестировщики)"
                    ],
                    "correct_answer": 3,
                    "explanation": "UML предназначен для улучшения коммуникации между всеми заинтересованными лицами (стейкхолдерами) на протяжении всего жизненного цикла разработки ПО."
                },
                {
                    "subid": 1.5,
                    "question": "Что из перечисленного НЕ является прямой задачей UML?",
                    "type": "singleanswer",
                    "options": [
                        "Специфицирование функциональных требований",
                        "Автоматическая оптимизация производительности готового кода",
                        "Визуализация компонентов системы и их взаимодействия",
                        "Документирование принятых проектных решений"
                    ],
                    "correct_answer": 1,
                    "explanation": "UML помогает формализовать и визуализировать требования и решения, но не занимается автоматической оптимизацией кода. Это задача компиляторов, профилировщиков и разработчиков."
                }
            ]
        },
        {
            "id": 2,
            "question": "Перечислите основные типы UML-диаграмм и к какому виду диаграмм (структурные, поведенческие, интерактивные) они относятся согласно версии UML 2.5?",
            "theory": "В UML 2.5 выделяется 14 типов диаграмм, которые группируются в две основные категории: Структурные диаграммы (Structural Diagrams) описывают статическую структуру системы, её «строительные блоки» независимо от времени. К ним относятся: 1) Диаграмма классов (Class Diagram) — показывает классы, их атрибуты, операции и отношения. 2) Диаграмма объектов (Object Diagram) — отображает снимок экземпляров классов в конкретный момент времени. 3) Диаграмма компонентов (Component Diagram) — иллюстрирует компоненты системы и их зависимости. 4) Диаграмма композитной структуры (Composite Structure Diagram) — раскрывает внутреннюю структуру класса. 5) Диаграмма развертывания (Deployment Diagram) — отображает физическое размещение компонентов на аппаратных узлах. 6) Диаграмма пакетов (Package Diagram) — показывает разделение системы на группы элементов (пакеты). Поведенческие диаграммы (Behavioral Diagrams) описывают динамическое поведение системы, изменения во времени. Их можно разделить на: A) Диаграммы, моделирующие поведение системы в целом: 7) Диаграмма активностей (Activity Diagram) — моделирует бизнес-процессы или алгоритмы как потоки работ. 8) Диаграмма состояний (State Machine Diagram) — показывает жизненный цикл объекта и его реакцию на события. B) Диаграммы взаимодействия (Interaction Diagrams) — подмножество поведенческих, фокусирующееся на обмене сообщениями между объектами: 9) Диаграмма последовательностей (Sequence Diagram) — акцентирует временной порядок сообщений. 10) Диаграмма коммуникации (Communication Diagram, ранее Collaboration Diagram) — акцентирует структурные аспекты взаимодействия объектов. 11) Диаграмма обзора взаимодействия (Interaction Overview Diagram) — высокоуровневое представление потока взаимодействий. 12) Диаграмма синхронизации (Timing Diagram) — фокусируется на временных ограничениях при взаимодействии. 13) Диаграмма вариантов использования (Use Case Diagram) — описывает функциональность системы с точки зрения внешних актеров. 14) Профили (Profiles) — не являются диаграммой в чистом виде, это механизм расширения UML для конкретных доменов.",
            "subquestions": [
                {
                    "subid": 2.1,
                    "question": "Какая из перечисленных диаграмм является структурной?",
                    "type": "singleanswer",
                    "options": [
                        "Диаграмма последовательностей",
                        "Диаграмма активностей",
                        "Диаграмма компонентов",
                        "Диаграмма вариантов использования"
                    ],
                    "correct_answer": 2,
                    "explanation": "Диаграмма компонентов показывает, из каких физических или логических модулей (компонентов) состоит система и как они связаны, что относится к статической структуре."
                },
                {
                    "subid": 2.2,
                    "question": "Диаграммы взаимодействия являются подвидом поведенческих диаграмм. Выберите все диаграммы взаимодействия.",
                    "type": "multiplyanswer",
                    "options": [
                        "Диаграмма классов",
                        "Диаграмма последовательностей",
                        "Диаграмма коммуникации",
                        "Диаграмма развертывания",
                        "Диаграмма синхронизации"
                    ],
                    "correct_answer": [
                        1,
                        2,
                        4
                    ],
                    "explanation": "К диаграммам взаимодействия (Interaction Diagrams) относятся диаграмма последовательностей, коммуникации, обзора взаимодействия и синхронизации. Их объединяет фокус на обмене сообщениями."
                },
                {
                    "subid": 2.3,
                    "question": "Какую диаграмму следует использовать для описания того, какие функции (варианты использования) предоставляет система внешним актерам?",
                    "type": "singleanswer",
                    "options": [
                        "Диаграмма состояний",
                        "Диаграмма объектов",
                        "Диаграмма вариантов использования",
                        "Диаграмма композитной структуры"
                    ],
                    "correct_answer": 2,
                    "explanation": "Диаграмма вариантов использования (Use Case Diagram) как раз и предназначена для моделирования функциональных требований к системе с точки зрения пользователей (актеров)."
                },
                {
                    "subid": 2.4,
                    "question": "Какая диаграмма показывает снимок системы в конкретный момент времени, отображая экземпляры классов и значения их атрибутов?",
                    "type": "singleanswer",
                    "options": [
                        "Диаграмма классов",
                        "Диаграмма объектов",
                        "Диаграмма активностей",
                        "Диаграмма пакетов"
                    ],
                    "correct_answer": 1,
                    "explanation": "Диаграмма объектов (Object Diagram) — это экземпляр диаграммы классов, показывающий конкретные объекты и связи между ними в определенный момент выполнения программы."
                },
                {
                    "subid": 2.5,
                    "question": "Для описания жизненного цикла заказа в системе электронной коммерции (состояния: 'Создан', 'Оплачен', 'Отправлен', 'Доставлен') лучше всего подойдет:",
                    "type": "singleanswer",
                    "options": [
                        "Диаграмма активностей",
                        "Диаграмма последовательностей",
                        "Диаграмма состояний (State Machine)",
                        "Диаграмма компонентов"
                    ],
                    "correct_answer": 2,
                    "explanation": "Диаграмма состояний (State Machine Diagram) идеально подходит для моделирования жизненного цикла объекта, показывая, в каких состояниях он может находиться и какие события вызывают переходы между этими состояниями."
                },
                {
                    "subid": 2.6,
                    "question": "Какие две основные категории диаграмм определены в UML 2.5?",
                    "type": "singleanswer",
                    "options": [
                        "Логические и физические",
                        "Статические и динамические",
                        "Структурные и поведенческие",
                        "Внутренние и внешние"
                    ],
                    "correct_answer": 2,
                    "explanation": "Фундаментальное разделение в UML — на структурные (static structure) и поведенческие (behavior) диаграммы. Это разделение отражает два основных взгляда на систему: «из чего она состоит» и «как она ведет себя»."
                }
            ]
        },
        {
            "id": 3,
            "question": "Что такое диаграмма классов (Class Diagram)? Какие ее основные элементы (сущности, атрибуты, операции, связи, ассоциации) и как они обозначаются?",
            "theory": "Диаграмма классов (Class Diagram) — это ключевая структурная диаграмма UML, которая отображает статическую структуру системы в терминологии объектно-ориентированного программирования. Она показывает классы, их внутреннюю структуру и отношения между ними. Основные элементы: 1. Класс (Class): изображается прямоугольником, разделенным на три секции: верхняя — имя класса (например, `Customer`), средняя — атрибуты (например, `-id: Integer`, `-name: String`), нижняя — операции (методы) (например, `+placeOrder(): Boolean`). Модификаторы доступа обозначаются: `+` (public), `-` (private), `#` (protected). 2. Атрибут (Attribute): свойство класса, описывающее его данные. Формат записи: `[видимость] имя [: тип] [кратность] [= значение по умолчанию]`. 3. Операция (Operation): метод или сервис, предоставляемый классом. Формат записи: `[видимость] имя [(список параметров)] [: возвращаемый тип]`. 4. Отношения (Relationships): - Ассоциация (Association): сплошная линия, показывает структурную связь между объектами классов (например, `Преподаватель` — `Студент`). Может иметь кратность (`1`, `*`, `0..1` и т.д.) и ролевые имена. - Агрегация (Aggregation): разновидность ассоциации «часть-целое» с нестрогим владением. Изображается линией с ромбом на стороне целого. - Композиция (Composition): более строгая форма агрегации, где часть не может существовать без целого. Ромб закрашен. - Обобщение (Generalization): отношение наследования. Стрелка с незакрашенным треугольником указывает от потомка к родителю. - Реализация (Realization): отношение реализации интерфейса. Пунктирная линия с незакрашенным треугольником от класса к интерфейсу.",
            "subquestions": [
                {
                    "subid": 3.1,
                    "question": "Как обозначается приватный атрибут `balance` типа `Double` на диаграмме классов?",
                    "type": "singleanswer",
                    "options": [
                        "+balance: Double",
                        "-balance: Double",
                        "#balance: Double",
                        "~balance: Double"
                    ],
                    "correct_answer": 1,
                    "explanation": "Символ `-` обозначает модификатор доступа `private`. Синтаксис: `[видимость] имя: тип`."
                },
                {
                    "subid": 3.2,
                    "question": "Какие из перечисленных элементов являются обязательными секциями в обозначении класса на диаграмме классов?",
                    "type": "multiplyanswer",
                    "options": [
                        "Имя класса",
                        "Секция атрибутов",
                        "Секция операций",
                        "Ни одна из секций не является строго обязательной — они могут быть опущены, если не релевантны"
                    ],
                    "correct_answer": [
                        0
                    ],
                    "explanation": "Единственная обязательная секция — это имя класса. Секции атрибутов и операций показываются только при необходимости для конкретной диаграммы."
                },
                {
                    "subid": 3.3,
                    "question": "Как обозначается отношение, при котором объект класса `Engine` не может существовать без объекта класса `Car`?",
                    "type": "singleanswer",
                    "options": [
                        "Ассоциация со стрелкой от Car к Engine",
                        "Агрегация (ромб на стороне Car)",
                        "Композиция (закрашенный ромб на стороне Car)",
                        "Зависимость (пунктирная стрелка от Car к Engine)"
                    ],
                    "correct_answer": 2,
                    "explanation": "Композиция (закрашенный ромб) обозначает строгое отношение «часть-целое», где время жизни части (Engine) совпадает со временем жизни целого (Car). Если Car уничтожается, то Engine тоже."
                },
                {
                    "subid": 3.4,
                    "question": "Что означает кратность `0..*` на конце ассоциации рядом с классом `Order` в связи между `Customer` и `Order`?",
                    "type": "singleanswer",
                    "options": [
                        "У одного заказа должен быть ровно один клиент",
                        "У одного клиента может быть ноль или более заказов",
                        "У одного заказа может быть ноль или несколько клиентов",
                        "У одного клиента должен быть хотя бы один заказ"
                    ],
                    "correct_answer": 1,
                    "explanation": "Кратность указывается на противоположном конце линии от класса. Если `Customer` — `Order` и `0..*` рядом с `Order`, это значит: один объект `Customer` может быть связан с нулем, одним или многими объектами `Order`."
                },
                {
                    "subid": 3.5,
                    "question": "Как на диаграмме классов обозначается статический метод (метод класса)?",
                    "type": "singleanswer",
                    "options": [
                        "Подчеркиванием имени метода",
                        "Использованием символа $ перед именем",
                        "Записью слова «static» перед типом возвращаемого значения",
                        "Подчеркиванием всей строки операции"
                    ],
                    "correct_answer": 3,
                    "explanation": "В нотации UML статические атрибуты и операции (принадлежащие классу, а не экземпляру) выделяются подчеркиванием их имени в соответствующей секции."
                }
            ]
        },
        {
            "id": 4,
            "question": "Какие существуют виды отношений между классами на диаграмме классов? Приведите примеры.",
            "theory": "На диаграмме классов существуют следующие основные виды отношений, каждый со своей семантикой и графическим обозначением: 1. **Ассоциация (Association)**: Базовая структурная связь, указывающая, что объекты одного класса каким-то образом связаны с объектами другого. Изображается сплошной линией. Может быть двунаправленной или однонаправленной (со стрелкой). Пример: `Преподаватель` — `Студент` (преподаватель обучает студентов). Характеризуется кратностью и ролевыми именами. 2. **Агрегация (Aggregation)**: Частный случай ассоциации, представляющий отношение «часть-целое» со слабым владением. Целое может существовать отдельно от своих частей. Графически — сплошная линия с пустым ромбом со стороны целого. Пример: `Кафедра` (целое) — `Преподаватель` (часть). Кафедра состоит из преподавателей, но если кафедру расформировать, преподаватели могут перейти на другую. 3. **Композиция (Composition)**: Более строгая форма агрегации с сильным владением. Часть не может существовать без целого и имеет с ним общее время жизни. Графически — сплошная линия с закрашенным ромбом со стороны целого. Пример: `Дом` (целое) — `Комната` (часть). Комната не может существовать без дома. При уничтожении дома комнаты также уничтожаются. 4. **Обобщение (Generalization)**: Отношение наследования («является»). Класс-потомок наследует структуру и поведение класса-родителя и может его расширять. Графически — сплошная линия с незакрашенной треугольной стрелкой, направленной от потомка к родителю. Пример: `ТранспортноеСредство` (родитель) ← `Автомобиль` (потомок). 5. **Реализация (Realization)**: Класс реализует (определяет) контракт, заданный интерфейсом. Графически — пунктирная линия с незакрашенной треугольной стрелкой от класса к интерфейсу. Пример: Класс `PDFDocument` реализует интерфейс `Printable`. 6. **Зависимость (Dependency)**: Отношение использования, при котором изменение в одном классе (поставщике) может повлиять на другой класс (клиент). Не является структурной связью. Возникает, когда класс использует другой в качестве параметра метода, локальной переменной и т.д. Графически — пунктирная линия со стрелкой от клиента к поставщику. Пример: Класс `ReportGenerator` зависит от класса `DataSource` (использует его в методе `generate(DataSource ds)`).",
            "subquestions": [
                {
                    "subid": 4.1,
                    "question": "Какое отношение следует использовать для моделирования связи «Университет состоит из Факультетов», если факультеты могут быть переведены в другой университет?",
                    "type": "singleanswer",
                    "options": [
                        "Композиция",
                        "Агрегация",
                        "Обобщение",
                        "Зависимость"
                    ],
                    "correct_answer": 1,
                    "explanation": "Поскольку факультеты могут существовать независимо от конкретного университета (могут быть переведены), это отношение «часть-целое» со слабым владением — агрегация."
                },
                {
                    "subid": 4.2,
                    "question": "Выберите все верные утверждения об отношении Обобщение (Generalization).",
                    "type": "multiplyanswer",
                    "options": [
                        "Обозначается закрашенным ромбом",
                        "Представляет отношение «является» (is-a)",
                        "Потомок наследует атрибуты и операции родителя",
                        "Может быть использовано для связи класса и интерфейса"
                    ],
                    "correct_answer": [
                        1,
                        2
                    ],
                    "explanation": "Обобщение обозначается незакрашенной треугольной стрелкой и представляет наследование (is-a). Связь класса с интерфейсом — это реализация (realization)."
                },
                {
                    "subid": 4.3,
                    "question": "Класс `Order` использует класс `PaymentProcessor` только в теле метода `processPayment()`. Какое между ними отношение?",
                    "type": "singleanswer",
                    "options": [
                        "Ассоциация",
                        "Агрегация",
                        "Композиция",
                        "Зависимость"
                    ],
                    "correct_answer": 3,
                    "explanation": "Если класс `Order` использует `PaymentProcessor` временно внутри метода (например, как локальную переменную или параметр), но не хранит его как поле, это указывает на отношение использования — зависимость (dependency)."
                },
                {
                    "subid": 4.4,
                    "question": "Как графически отличить Композицию от Агрегации на диаграмме?",
                    "type": "singleanswer",
                    "options": [
                        "По типу линии: сплошная у композиции, пунктирная у агрегации",
                        "По форме стрелки на конце линии",
                        "По заливке ромба: закрашенный у композиции, пустой у агрегации",
                        "По подписи над линией"
                    ],
                    "correct_answer": 2,
                    "explanation": "Ключевое визуальное отличие — ромб на стороне целого: закрашенный (черный) для композиции и незакрашенный (пустой) для агрегации. Линия в обоих случаях сплошная."
                },
                {
                    "subid": 4.5,
                    "question": "Какое отношение НЕ является структурным (т.е. не определяет постоянную связь между объектами)?",
                    "type": "singleanswer",
                    "options": [
                        "Ассоциация",
                        "Обобщение",
                        "Зависимость",
                        "Агрегация"
                    ],
                    "correct_answer": 2,
                    "explanation": "Зависимость (Dependency) — это отношение использования, которое не создает постоянной структурной связи между экземплярами классов. Оно указывает на временное, параметрическое или локальное использование. Остальные отношения (ассоциация, агрегация, композиция, обобщение) определяют статическую структуру системы."
                }
            ]
        },
        {
            "id": 5,
            "question": "Что такое ассоциация (Association) на диаграмме классов? Какие атрибуты и ролевое имя можно ей присваивать?",
            "theory": "**Ассоциация (Association)** — это фундаментальное отношение в UML, которое описывает структурную связь между двумя или более классами, указывая, что объекты одного класса каким-то образом связаны с объектами другого. Это семантическая связь, которая может существовать между экземплярами связанных классов. Графически изображается сплошной линией между классами. Ассоциация может быть: - **Двунаправленной**: связь по умолчанию, подразумевает, что оба класса «знают» друг о друге. - **Однонаправленной**: обозначается стрелкой на конце линии, указывающей направление навигации (какой класс «видит» другой). Класс, к которому ведет стрелка, является видимым для класса в начале линии. Ассоциации могут быть обогащены следующими свойствами: 1. **Имя ассоциации (Association Name)**: глагол или глагольная фраза, читаемая по направлению стрелки, которая поясняет природу связи (например, «работает в», «обучает»). 2. **Ролевые имена (Role Names)**: указываются на концах линии ассоциации рядом с классом. Ролевое имя описывает роль, которую объект целевого класса играет в контексте исходящего класса. Например, у класса `Company` роль может быть `employer`, а у класса `Person` — `employee`. 3. **Кратность (Multiplicity)**: определяет, сколько объектов одного класса может быть связано с одним объектом другого класса. Указывается на противоположном конце линии. Примеры: `1` (ровно один), `0..1` (ноль или один), `*` или `0..*` (много, ноль или более), `1..*` (один или более), `2..4` (диапазон). 4. **Ассоциативный класс (Association Class)**: когда у самой связи есть атрибуты и/или операции, ее представляют в виде класса, соединенного с линией ассоциации пунктирной линией. Пример: связь `Student` — `Course` может иметь ассоциативный класс `Enrollment` с атрибутами `grade`, `enrollmentDate`.",
            "subquestions": [
                {
                    "subid": 5.1,
                    "question": "Что означает стрелка на конце линии ассоциации?",
                    "type": "singleanswer",
                    "options": [
                        "Направление потока данных",
                        "Направление наследования",
                        "Направление навигации (видимости)",
                        "Обязательность связи"
                    ],
                    "correct_answer": 2,
                    "explanation": "Стрелка указывает направление навигации. Если от класса A к классу B ведет стрелка, это значит, что класс A «знает» о классе B и может к нему обратиться, но обратная видимость не гарантируется (она может быть, но не обязана)."
                },
                {
                    "subid": 5.2,
                    "question": "Выберите все элементы, которые могут характеризовать ассоциацию.",
                    "type": "multiplyanswer",
                    "options": [
                        "Имя ассоциации",
                        "Ролевое имя",
                        "Кратность",
                        "Тип возвращаемого значения"
                    ],
                    "correct_answer": [
                        0,
                        1,
                        2
                    ],
                    "explanation": "Ассоциацию можно описать именем (например, «владеет»), ролевыми именами на концах (например, `owner` и `pet`) и кратностью (например, `1` и `1..*`). Тип возвращаемого значения — характеристика операции класса, а не ассоциации."
                },
                {
                    "subid": 5.3,
                    "question": "Какой символ используется для обозначения кратности «ноль или более»?",
                    "type": "singleanswer",
                    "options": [
                        "0..1",
                        "1",
                        "*",
                        "+"
                    ],
                    "correct_answer": 2,
                    "explanation": "Символ `*` (звездочка) в UML является стандартным обозначением для множественности «ноль или более» (`0..*`)."
                },
                {
                    "subid": 5.4,
                    "question": "В чем разница между ролевым именем и именем ассоциации?",
                    "type": "singleanswer",
                    "options": [
                        "Ролевое имя — это существительное, описывающее функцию класса в связи, а имя ассоциации — глагол, описывающий саму связь.",
                        "Ролевое имя указывается над линией, а имя ассоциации — под ней.",
                        "Это синонимы.",
                        "Ролевое имя относится только к агрегации."
                    ],
                    "correct_answer": 0,
                    "explanation": "Ролевое имя (например, `employer`) — это существительное, обозначающее роль, которую экземпляр класса играет в контексте связи. Имя ассоциации (например, «работает в») — это глагол или глагольная фраза, которая называет сам факт связи."
                },
                {
                    "subid": 5.5,
                    "question": "Когда необходимо использовать ассоциативный класс?",
                    "type": "singleanswer",
                    "options": [
                        "Когда связь между классами имеет собственные атрибуты или поведение.",
                        "Когда связь является однонаправленной.",
                        "Когда кратность связи равна 1.",
                        "Когда один из классов является абстрактным."
                    ],
                    "correct_answer": 0,
                    "explanation": "Ассоциативный класс применяется, когда сама связь (факт ассоциации) обладает свойствами, которые нельзя приписать ни одному из связанных классов. Например, дата регистрации (`enrollmentDate`) и оценка (`grade`) — это свойства связи «Студент записан на Курс», а не свойства студента или курса по отдельности."
                }
            ]
        },
        {
            "id": 6,
            "question": "Дайте определение диаграммы последовательностей (Sequence Diagram). Какие ее основные элементы (актеры, объекты, жизни, сообщения) изображаются?",
            "theory": "**Диаграмма последовательностей (Sequence Diagram)** — это вид поведенческой диаграммы (из группы диаграмм взаимодействия) в UML, который показывает временную последовательность сообщений, которыми обмениваются объекты (или актеры) для выполнения конкретного сценария или операции. Она фокусируется на порядке вызовов во времени, что делает её незаменимой для моделирования логики методов, use case или сложных протоколов взаимодействия. Основные элементы: 1. **Актер (Actor)**: внешняя сущность (пользователь, система), инициирующая взаимодействие. Изображается стилизованной человеческой фигурой. 2. **Объект (Object/Lifeline)**: экземпляр класса, компонента или актера, участвующий во взаимодействии. Изображается прямоугольником с именем объекта (подчеркнутым) и классом (например, `client: Client`). 3. **Линия жизни (Lifeline)**: вертикальная пунктирная линия, исходящая из объекта. Представляет собой временную шкалу существования объекта в течение взаимодействия. 4. **Фокус управления (Activation Bar/Execution Occurrence)**: тонкий прямоугольник на линии жизни, показывающий период, когда объект активен (выполняет операцию или обрабатывает сообщение). 5. **Сообщения (Messages)**: стрелки между линиями жизни, обозначающие коммуникацию. Типы сообщений: - **Синхронное сообщение (Synchronous)**: сплошная линия со сплошной стрелкой. Отправитель ждет завершения операции (возврата управления). - **Асинхронное сообщение (Asynchronous)**: сплошная линия с открытой стрелкой. Отправитель не ждет, продолжает выполнение. - **Возвратное сообщение (Reply/Return)**: пунктирная линия с открытой стрелкой. Показывает возврат значения или управления от вызванной операции. - **Сообщение о создании (Create Message)**: стрелка с пунктирной линией и текстом «create». Указывает на создание нового объекта. - **Сообщение об уничтожении (Delete Message)**: стрелка с крестом в конце. Указывает на уничтожение объекта. 6. **Ограничительные рамки (Interaction Frames)**: прямоугольные области для обозначения альтернатив, циклов, параллелизма и т.д. (например, `alt`, `loop`, `opt`, `par`).",
            "subquestions": [
                {
                    "subid": 6.1,
                    "question": "Что представляет собой вертикальная пунктирная линия, исходящая из объекта на диаграмме последовательностей?",
                    "type": "singleanswer",
                    "options": [
                        "Атрибут объекта",
                        "Линия жизни (Lifeline)",
                        "Фокус управления (Activation Bar)",
                        "Возвратное сообщение"
                    ],
                    "correct_answer": 1,
                    "explanation": "Линия жизни (Lifeline) — это вертикальная пунктирная линия, которая показывает время жизни объекта в рамках изображаемого взаимодействия."
                },
                {
                    "subid": 6.2,
                    "question": "Какой тип сообщения следует использовать для вызова обычного метода, когда вызывающий объект ждет его завершения?",
                    "type": "singleanswer",
                    "options": [
                        "Асинхронное сообщение (открытая стрелка)",
                        "Синхронное сообщение (сплошная стрелка)",
                        "Возвратное сообщение (пунктирная линия)",
                        "Сообщение о создании"
                    ],
                    "correct_answer": 1,
                    "explanation": "Вызов метода, блокирующий выполнение вызывающего объекта до возврата из метода, моделируется синхронным сообщением (сплошная линия со сплошной наконечником стрелки)."
                },
                {
                    "subid": 6.3,
                    "question": "Что показывает тонкий прямоугольник на линии жизни объекта?",
                    "type": "singleanswer",
                    "options": [
                        "Время создания объекта",
                        "Период активности объекта (выполнение операции) — фокус управления",
                        "Время уничтожения объекта",
                        "Состояние объекта"
                    ],
                    "correct_answer": 1,
                    "explanation": "Это фокус управления (Activation Bar) или Execution Occurrence. Он показывает временной промежуток, в течение которого объект выполняет действие, прямо или косвенно, в результате получения сообщения."
                },
                {
                    "subid": 6.4,
                    "question": "Выберите все верные утверждения об актерах на диаграмме последовательностей.",
                    "type": "multiplyanswer",
                    "options": [
                        "Актер всегда является частью программной системы",
                        "Актер инициирует взаимодействие с системой",
                        "Актер изображается прямоугольником с именем класса",
                        "Актер представляет роль пользователя или внешней системы"
                    ],
                    "correct_answer": [
                        1,
                        3
                    ],
                    "explanation": "Актер — это внешняя по отношению к моделируемой системе сущность (например, пользователь, сторонний сервис). Он инициирует сценарий и изображается стилизованной фигуркой человека."
                },
                {
                    "subid": 6.5,
                    "question": "Какой элемент диаграммы используется для визуального группирования альтернативных сценариев (if-else)?",
                    "type": "singleanswer",
                    "options": [
                        "Линия жизни",
                        "Фокус управления",
                        "Ограничительная рамка (frame) с оператором `alt`",
                        "Асинхронное сообщение"
                    ],
                    "correct_answer": 2,
                    "explanation": "Для изображения условной логики (альтернатив) используется ограничительная рамка (interaction frame) с оператором `alt`. Внутри рамки разделяются участки (operands) для каждого варианта условия."
                }
            ]
        },
        {
            "id": 7,
            "question": "Что такое фильтр вариантов (Alt), и как он используется на последовательностных диаграммах?",
            "theory": "**Фильтр вариантов (Alt)** — это один из типов ограничительных рамок (Interaction Frames), используемых на диаграммах последовательностей UML для моделирования условной логики, аналогичной операторам `if-then-else` или `switch-case` в языках программирования. Рамка `alt` разделяет диаграмму на несколько операдантов (регионов), каждый из которых представляет отдельный вариант выполнения в зависимости от заданного охраняющего условия (guard condition). Использование: 1. Рамка `alt` рисуется как прямоугольник, охватывающий соответствующие фрагменты последовательности. В левом верхнем углу рамки указывается оператор `alt`. 2. Внутри рамки диагональными пунктирными линиями разделяются операданты (варианты). 3. Каждый операдант начинается с охраняющего условия в квадратных скобках `[условие]`. Условие — это булево выражение, которое может включать атрибуты объектов, параметры сообщений и т.д. 4. Выполняется только тот операдант, чье охраняющее условие принимает значение `true`. Если ни одно условие не истинно, может быть предусмотрен операдант `else`. 5. Сообщения и активности внутри выбранного операданта выполняются в указанном порядке. Пример: При обработке заказа может быть рамка `alt` с двумя операдантами: `[заказ подтвержден]` — отправка сообщения о подтверждении, и `[заказ отклонен]` — отправка сообщения об отказе. Рамка `alt` позволяет наглядно показать ветвление потока управления в зависимости от условий, делая диаграмму более информативной и точной для описания сложного поведения.",
            "subquestions": [
                {
                    "subid": 7.1,
                    "question": "Как обозначается охраняющее условие для варианта внутри рамки `alt`?",
                    "type": "singleanswer",
                    "options": [
                        "В фигурных скобках {}",
                        "В квадратных скобках []",
                        "В круглых скобках ()",
                        "С помощью специальной нотации перед сообщением"
                    ],
                    "correct_answer": 1,
                    "explanation": "Охраняющее условие (guard condition) всегда записывается в квадратных скобках `[ ]` и размещается в начале соответствующего операданта внутри рамки."
                },
                {
                    "subid": 7.2,
                    "question": "Что произойдет, если в рамках `alt` истинными окажутся несколько охраняющих условий?",
                    "type": "singleanswer",
                    "options": [
                        "Будут выполнены все соответствующие варианты параллельно",
                        "Будет выполнен только первый по порядку истинный вариант",
                        "Поведение не определено спецификацией UML",
                        "Это ошибочная ситуация, которую следует избегать при проектировании"
                    ],
                    "correct_answer": 1,
                    "explanation": "В соответствии с семантикой UML, если несколько условий истинны, должен выполняться только один вариант. Обычно подразумевается, что условия должны быть взаимоисключающими. Если это не так, выполняется первый истинный вариант (хотя на практике проектировщик должен обеспечивать взаимную исключительность)."
                },
                {
                    "subid": 7.3,
                    "question": "Какой операдант внутри `alt` будет выполнен, если ни одно из явных условий не истинно?",
                    "type": "singleanswer",
                    "options": [
                        "Будет выполнен первый операдант",
                        "Взаимодействие завершится с ошибкой",
                        "Можно определить операдант с условием `[else]`",
                        "Ни один операдант не выполнится, и поток перейдет к элементам после рамки"
                    ],
                    "correct_answer": 2,
                    "explanation": "Для обработки всех остальных случаев можно (и часто нужно) использовать специальный операдант с охраняющим условием `[else]`. Если его нет и все условия ложны, то ни один из вариантов внутри `alt` не выполняется."
                },
                {
                    "subid": 7.4,
                    "question": "Чем рамка `opt` принципиально отличается от рамки `alt`?",
                    "type": "singleanswer",
                    "options": [
                        "`opt` используется для циклов, а `alt` — для условий",
                        "`opt` содержит только один операдант, который выполняется при истинности условия, а `alt` — несколько взаимоисключающих вариантов",
                        "`opt` используется для параллельного выполнения, а `alt` — для последовательного",
                        "Ничем, это синонимы"
                    ],
                    "correct_answer": 1,
                    "explanation": "Рамка `opt` (optional) моделирует выполнение одного возможного фрагмента последовательности при истинности условия (аналог `if` без `else`). Рамка `alt` предназначена для выбора между двумя или более альтернативами (аналог `if-else` или `switch`)."
                },
                {
                    "subid": 7.5,
                    "question": "Можно ли внутри одного операданта рамки `alt` размещать другие рамки (например, `loop` или другую `alt`)?",
                    "type": "singleanswer",
                    "options": [
                        "Нет, вложенность рамок запрещена",
                        "Да, рамки могут быть вложенными для моделирования сложной логики",
                        "Можно, но только если внешняя рамка — `alt`",
                        "Можно, но только если внутренняя рамка — `opt`"
                    ],
                    "correct_answer": 1,
                    "explanation": "Ограничительные рамки (interaction frames), включая `alt`, `loop`, `opt`, `par`, могут быть вложенными друг в друга для детального описания сложного потока управления и взаимодействий."
                }
            ]
        },
        {
            "id": 8,
            "question": "Объясните назначение и основные элементы диаграммы состояний объекта (State Diagram). Какие типы состояний существуют?",
            "theory": "**Диаграмма состояний (State Machine Diagram или Statechart Diagram)** — это поведенческая диаграмма UML, которая моделирует динамическое поведение отдельного объекта (или системы в контексте одного объекта) в течение его жизненного цикла. Она показывает последовательность состояний, через которые проходит объект в ответ на события, а также его реакции (действия) и условия перехода между состояниями. Основные элементы: 1. **Состояние (State)**: Период в жизни объекта, когда он удовлетворяет некоторому условию, выполняет определенную деятельность или ожидает события. Изображается прямоугольником со скругленными углами. Состояния могут иметь внутреннюю деятельность: - **Entry activity**: действие, выполняемое при входе в состояние (запись `entry / действие`). - **Exit activity**: действие при выходе (`exit / действие`). - **Do activity**: продолжительная деятельность, выполняемая, пока объект находится в состоянии (`do / деятельность`). - **Событие (Event)**: может обрабатываться внутри состояния без перехода. 2. **Начальное состояние (Initial State)**: Черный закрашенный кружок. Точка входа в автомат состояний. 3. **Конечное состояние (Final State)**: Кружок с концентрической окружностью внутри. Обозначает завершение жизненного цикла объекта. 4. **Переход (Transition)**: Направленная стрелка от исходного состояния к целевому. Пометка перехода имеет формат: `событие [охраняющее условие] / действие`. 5. **Составное состояние (Composite State)**: Состояние, которое содержит внутри себя вложенные подсостояния (substates) или другие автоматы. Упрощает сложные диаграммы. Может быть последовательным (OR-состояние) или параллельным (AND-состояние). 6. **Псевдосостояние выбора (Choice Pseudostate)**: Ромб, позволяющий ветвить переходы на основе охраняющих условий (аналог `if-else`). 7. **Псевдосостояние соединения/разветвления (Junction/Fork Pseudostate)**: Маленький черный кружок (junction) для слияния/разделения переходов; толстая горизонтальная/вертикальная линия (fork/join) для обозначения параллельных регионов внутри составного состояния. **Типы состояний**: - **Простое состояние (Simple State)**: Не имеет внутренней структуры (подсостояний). - **Составное состояние (Composite State)**: Содержит вложенные состояния. - **Субмашина состояния (Submachine State)**: Ссылается на внешнюю, независимую диаграмму состояний. - **Историческое состояние (History State)**: Псевдосостояние (H или H*), обозначающее точку, в которую объект возвращается, чтобы возобновить предыдущее активное подсостояние составного состояния.",
            "subquestions": [
                {
                    "subid": 8.1,
                    "question": "Какое действие, указанное в состоянии как `do / проверять датчик`, выполняется?",
                    "type": "singleanswer",
                    "options": [
                        "Действие при входе в состояние",
                        "Действие при выходе из состояния",
                        "Продолжительная деятельность, выполняемая, пока объект находится в состоянии",
                        "Действие, выполняемое при получении конкретного события"
                    ],
                    "correct_answer": 2,
                    "explanation": "Деятельность, обозначенная ключевым словом `do`, является длительным (возможно, непрерывным) процессом, который выполняется, пока объект пребывает в данном состоянии. Она может быть прервана событием, вызывающим переход."
                },
                {
                    "subid": 8.2,
                    "question": "Какой элемент диаграммы состояний обозначает точку, куда объект возвращается, чтобы восстановить последнее активное подсостояние?",
                    "type": "singleanswer",
                    "options": [
                        "Начальное состояние",
                        "Конечное состояние",
                        "Историческое состояние (H)",
                        "Псевдосостояние выбора"
                    ],
                    "correct_answer": 2,
                    "explanation": "Историческое псевдосостояние (обозначается буквой `H` внутри круга) позволяет автомату состояний «запомнить» последнее активное подсостояние составного состояния и вернуться в него при последующем входе."
                },
                {
                    "subid": 8.3,
                    "question": "Выберите все верные утверждения о составных состояниях (Composite State).",
                    "type": "multiplyanswer",
                    "options": [
                        "Могут содержать вложенные подсостояния",
                        "Упрощают диаграмму, скрывая сложность",
                        "Всегда содержат параллельные регионы",
                        "Переход, входящий в границу составного состояния, обычно ведет в начальное подсостояние"
                    ],
                    "correct_answer": [
                        0,
                        1,
                        3
                    ],
                    "explanation": "Составное состояние инкапсулирует внутренний автомат из подсостояний, что повышает читаемость. Оно может содержать как последовательные, так и параллельные регионы. Переход, целевым состоянием которого является составное состояние, на самом деле ведет в его начальное подсостояние (если не указано иное)."
                },
                {
                    "subid": 8.4,
                    "question": "Что из перечисленного НЕ является типом состояния в UML?",
                    "type": "singleanswer",
                    "options": [
                        "Простое состояние",
                        "Абстрактное состояние",
                        "Составное состояние",
                        "Субмашина состояния"
                    ],
                    "correct_answer": 1,
                    "explanation": "В UML не существует специального типа «абстрактное состояние». Есть простые, составные, субмашины и исторические псевдосостояния. «Абстрактность» — это характеристика класса, а не состояния."
                },
                {
                    "subid": 8.5,
                    "question": "Какое из обозначений соответствует охраняющему условию на переходе?",
                    "type": "singleanswer",
                    "options": [
                        "`onButtonPress / turnOnLight`",
                        "`[temperature > 30]`",
                        "`entry / initialize`",
                        "`do / monitor`"
                    ],
                    "correct_answer": 1,
                    "explanation": "Охраняющее условие на переходе всегда записывается в квадратных скобках `[ ]` после имени события. Оно определяет булево выражение, которое должно быть истинным, чтобы переход мог произойти после наступления события."
                }
            ]
        },
        {
            "id": 9,
            "question": "Что такое переход (Transition) в диаграмме состояний? Как он определяется?",
            "theory": "**Переход (Transition)** в диаграмме состояний — это направленная связь между двумя состояниями, которая показывает, что объект может изменить свое текущее состояние на целевое в ответ на наступление определенного события, при выполнении указанного условия. Переход определяет реакцию объекта на события. Полная нотация перехода имеет следующий формат: `событие [охраняющее условие] / действие ^ событие-для-отправки`. - **Событие (Event)**: Триггер, который инициирует проверку возможности перехода. Если событие происходит и объект находится в исходном состоянии, переход может «сработать». Типы событий: вызов операции (call event), изменение значения (change event `when(выражение)`), истечение времени (time event `after(время)`), получение сигнала (signal event). - **Охраняющее условие (Guard Condition)**: Булево выражение в квадратных скобках `[ ]`, которое вычисляется после наступления события. Переход может произойти только если условие истинно (`true`). Если условие ложно, переход игнорируется, даже если событие произошло. - **Действие (Action)**: Исполняемое атомарное поведение (например, вызов операции, присваивание значения), которое выполняется в момент осуществления перехода. Указывается после косой черты `/`. Действия считаются быстрыми и не должны занимать значительное время. - **Событие-для-отправки (Send Event)**: Необязательная часть. Позволяет указать, что в процессе перехода объект отправляет сообщение (сигнал) другому объекту. Обозначается символом `^` и именем события-получателя. **Особые типы переходов**: - **Внутренний переход (Internal Transition)**: Список событий с действиями внутри состояния. При их возникновении выполняются указанные действия, но состояние объекта не меняется (не вызываются entry/exit действия). - **Само-переход (Self-Transition)**: Переход, у которого исходное и целевое состояния совпадают. При его выполнении сначала выполняются exit-действия исходного состояния, затем действие перехода, а затем entry-действия (того же состояния).",
            "subquestions": [
                {
                    "subid": 9.1,
                    "question": "В каком порядке выполняются действия при срабатывании перехода из состояния А в состояние Б?",
                    "type": "singleanswer",
                    "options": [
                        "Действие перехода, затем exit-действие А, затем entry-действие Б",
                        "Exit-действие А, затем действие перехода, затем entry-действие Б",
                        "Entry-действие Б, затем действие перехода, затем exit-действие А",
                        "Действие перехода, затем entry-действие Б, затем exit-действие А"
                    ],
                    "correct_answer": 1,
                    "explanation": "Стандартный порядок при переходе: 1) Выполняется exit-действие исходного состояния (A), 2) Выполняется действие, указанное на самом переходе, 3) Выполняется entry-действие целевого состояния (B)."
                },
                {
                    "subid": 9.2,
                    "question": "Что произойдет, если при наступлении события `doorOpened` охраняющее условие `[isAuthorized == false]` окажется ложным?",
                    "type": "singleanswer",
                    "options": [
                        "Переход сработает, но действие выполнено не будет",
                        "Переход не сработает, и объект останется в текущем состоянии",
                        "Объект перейдет в специальное состояние ошибки",
                        "Будет выполнен переход по умолчанию (если есть)"
                    ],
                    "correct_answer": 1,
                    "explanation": "Охраняющее условие — это фильтр. Если условие ложно, переход не активируется, событие игнорируется (в контексте этого перехода), и объект продолжает находиться в исходном состоянии."
                },
                {
                    "subid": 9.3,
                    "question": "Какое событие сработает при истинности выражения `temperature > 100`?",
                    "type": "singleanswer",
                    "options": [
                        "Call event",
                        "Signal event",
                        "Change event (`when(temperature > 100)`)",
                        "Time event (`after(10s)`)"
                    ],
                    "correct_answer": 2,
                    "explanation": "Событие изменения (change event) инициируется, когда указанное булево выражение становится истинным. Оно записывается с ключевым словом `when`."
                },
                {
                    "subid": 9.4,
                    "question": "Чем внутренний переход (internal transition) отличается от само-перехода (self-transition)?",
                    "type": "singleanswer",
                    "options": [
                        "Это одно и то же",
                        "При внутреннем переходе не вызываются entry/exit действия состояния",
                        "Само-переход не может иметь охраняющего условия",
                        "Внутренний переход ведет в другое состояние"
                    ],
                    "correct_answer": 1,
                    "explanation": "Ключевое отличие: при внутреннем переходе объект формально не покидает состояние, поэтому entry и exit действия НЕ выполняются. При само-переходе объект выходит и снова входит в то же состояние, поэтому exit и entry действия выполняются."
                },
                {
                    "subid": 9.5,
                    "question": "Что означает запись `buttonPressed [batteryLevel > 0] / turnOn ^ LightOnSignal` на переходе?",
                    "type": "singleanswer",
                    "options": [
                        "При событии buttonPressed, если batteryLevel > 0, выполнится действие turnOn, а затем объект отправит сигнал LightOnSignal",
                        "Событие buttonPressed произойдет только после отправки LightOnSignal",
                        "Условие batteryLevel > 0 проверяется до наступления события buttonPressed",
                        "Действие turnOn выполнится только после получения ответа на LightOnSignal"
                    ],
                    "correct_answer": 0,
                    "explanation": "Запись следует читать как: Событие-триггер: `buttonPressed`. Условие: `[batteryLevel > 0]`. Действие при переходе: `/ turnOn`. Отправка сигнала другому объекту: `^ LightOnSignal`. Все происходит в указанном порядке при срабатывании перехода."
                }
            ]
        },
        {
            "id": 10,
            "question": "Опишите назначение и основные элементы диаграммы активностей (Activity Diagram). Какие типы узлов (Action, Decision, Merge, Initial, Final, Fork, Join) используются?",
            "theory": "**Диаграмма активностей (Activity Diagram)** — это поведенческая диаграмма UML, используемая для моделирования бизнес-процессов, рабочих процессов (workflows), алгоритмов или последовательности операций в системе. Она визуализирует поток управления (control flow) и/или поток данных (object flow) от одной деятельности к другой. Похожа на блок-схему, но обладает более богатой семантикой для параллелизма и объектных потоков. Основные элементы: 1. **Действие (Action Node)**: Атомарная единица поведения, представляющая один шаг в процессе (например, «Проверить наличие», «Отправить уведомление»). Изображается прямоугольником со скругленными углами. 2. **Узел управления (Control Nodes)**: - **Начальный узел (Initial Node)**: Сплошной черный кружок. Точка начала потока. - **Финальный узел (Activity Final Node)**: Концентрический кружок (круг в круге). Завершает весь поток активности. - **Узел потока (Fork/Join Node)**: Толстая горизонтальная или вертикальная черта. **Fork** разделяет один входящий поток на несколько параллельных исходящих потоков. **Join** синхронизирует несколько входящих параллельных потоков в один исходящий (ждет завершения всех). - **Узел решения (Decision Node)**: Ромб. Разделяет поток на несколько альтернативных путей на основе охраняющих условий (guard). У каждого исходящего потока должно быть условие в квадратных скобках `[ ]`. - **Узел слияния (Merge Node)**: Ромб. Объединяет несколько альтернативных потоков обратно в один. Не синхронизирует (в отличие от Join), просто сводит пути. 3. **Объектный узел (Object Node)**: Прямоугольник. Показывает данные или объекты, которые производятся или потребляются действиями. Может представлять входные/выходные параметры действий. 4. **Дорожки (Swimlanes)**: Вертикальные или горизонтальные разделы диаграммы, которые группируют действия по ответственности (например, по ролям, отделам, компонентам системы). 5. **Поток управления (Control Flow)**: Сплошная линия со стрелкой, показывающая последовательность выполнения действий. 6. **Поток объектов (Object Flow)**: Пунктирная линия со стрелкой, показывающая передачу объекта (данных) от действия-источника к действию-приемнику. 7. **Узел отправки/приема сигналов (Send/Receive Signal)**: Прямоугольник с «зазубренным» краем (отправка) или вогнутым краем (прием). Показывает асинхронную коммуникацию с внешними процессами.",
            "subquestions": [
                {
                    "subid": 10.1,
                    "question": "Какой узел используется для запуска нескольких параллельных потоков действий?",
                    "type": "singleanswer",
                    "options": [
                        "Узел решения (Decision Node)",
                        "Узел слияния (Merge Node)",
                        "Узел ветвления (Fork Node)",
                        "Начальный узел (Initial Node)"
                    ],
                    "correct_answer": 2,
                    "explanation": "Узел ветвления (Fork Node), изображаемый толстой чертой, принимает один поток управления и порождает из него несколько параллельных (concurrent) потоков, которые выполняются одновременно."
                },
                {
                    "subid": 10.2,
                    "question": "Чем узел слияния (Merge) отличается от узла соединения (Join)?",
                    "type": "singleanswer",
                    "options": [
                        "Merge объединяет альтернативные потоки, Join синхронизирует параллельные",
                        "Merge синхронизирует параллельные потоки, Join объединяет альтернативные",
                        "Merge использует охраняющие условия, Join — нет",
                        "Это разные названия одного и того же узла"
                    ],
                    "correct_answer": 0,
                    "explanation": "Merge Node (ромб) используется для слияния нескольких альтернативных (взаимоисключающих) потоков, пришедших из Decision Node, обратно в один поток. Join Node (толстая линия) ждет завершения ВСЕХ входящих параллельных потоков, прежде чем передать управление дальше."
                },
                {
                    "subid": 10.3,
                    "question": "Что произойдет, когда поток управления достигнет узла Activity Final Node?",
                    "type": "singleanswer",
                    "options": [
                        "Завершится только текущий поток, другие параллельные потоки продолжат работу",
                        "Будет прервано выполнение всех действий и потоков в пределах данной активности",
                        "Поток вернется к начальному узлу",
                        "Ничего, это просто маркер"
                    ],
                    "correct_answer": 1,
                    "explanation": "Узел завершения активности (Activity Final Node) означает полное завершение всей активности. При его достижении прекращается выполнение всех действий и потоков управления в рамках этой диаграммы активностей."
                },
                {
                    "subid": 10.4,
                    "question": "Выберите все верные утверждения об охраняющих условиях (guards) на диаграмме активностей.",
                    "type": "multiplyanswer",
                    "options": [
                        "Они записываются в квадратных скобках рядом с исходящим потоком из узла Decision",
                        "Они могут быть только у потоков, исходящих из узла Fork",
                        "Условия на потоках из Decision должны покрывать все возможные случаи",
                        "Они определяют булево выражение, которое должно быть истинным для прохождения по данному потоку"
                    ],
                    "correct_answer": [
                        0,
                        2,
                        3
                    ],
                    "explanation": "Охраняющие условия используются на исходящих потоках из узла Decision (решения). Они должны быть взаимоисключающими и, желательно, покрывать все возможности. Условие оценивается, чтобы выбрать, по какому пути пойдет поток управления."
                },
                {
                    "subid": 10.5,
                    "question": "Для чего используются дорожки (Swimlanes) на диаграмме активностей?",
                    "type": "singleanswer",
                    "options": [
                        "Для обозначения параллельных потоков",
                        "Для визуального разделения ответственности за действия между участниками процесса",
                        "Для обозначения условий ветвления",
                        "Для связи с объектными узлами"
                    ],
                    "correct_answer": 1,
                    "explanation": "Дорожки (Swimlanes) — это вертикальные или горизонтальные колонки/строки, которые группируют действия по ответственному исполнителю (роль, система, организационная единица). Это помогает понять, кто и что делает в процессе."
                }
            ]
        }
    ]
}